"use strict";(self.webpackChunkstorybook=self.webpackChunkstorybook||[]).push([[8774],{"../packages/ui/node_modules/@dnd-kit/core/dist/core.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{AutoScrollActivator:()=>AutoScrollActivator,DndContext:()=>DndContext,DragOverlay:()=>DragOverlay,KeyboardCode:()=>KeyboardCode,KeyboardSensor:()=>KeyboardSensor,MeasuringFrequency:()=>MeasuringFrequency,MeasuringStrategy:()=>MeasuringStrategy,MouseSensor:()=>MouseSensor,PointerSensor:()=>PointerSensor,TouchSensor:()=>TouchSensor,TraversalOrder:()=>TraversalOrder,applyModifiers:()=>applyModifiers,closestCenter:()=>closestCenter,closestCorners:()=>closestCorners,defaultAnnouncements:()=>defaultAnnouncements,defaultCoordinates:()=>defaultCoordinates,defaultDropAnimation:()=>defaultDropAnimation,getBoundingClientRect:()=>getBoundingClientRect,getLayoutRect:()=>getLayoutRect,getScrollableAncestors:()=>getScrollableAncestors,getViewRect:()=>getViewRect,getViewportLayoutRect:()=>getViewportLayoutRect,rectIntersection:()=>rectIntersection,useDndContext:()=>useDndContext,useDndMonitor:()=>useDndMonitor,useDraggable:()=>useDraggable,useDroppable:()=>useDroppable,useSensor:()=>useSensor,useSensors:()=>useSensors});var Action,Direction,AutoScrollActivator,TraversalOrder,MeasuringStrategy,MeasuringFrequency,EventName,KeyboardCode,MouseButton,react=__webpack_require__("./node_modules/react/index.js"),react_dom=__webpack_require__("../packages/ui/node_modules/react-dom/index.js"),utilities_esm=__webpack_require__("../packages/ui/node_modules/@dnd-kit/utilities/dist/utilities.esm.js");let hiddenStyles={display:"none"};function HiddenText(_ref){let{id,value}=_ref;return react.createElement("div",{id:id,style:hiddenStyles},value)}function LiveRegion(_ref){let{id,announcement,ariaLiveType="assertive"}=_ref;return react.createElement("div",{id:id,style:{position:"fixed",width:1,height:1,margin:-1,border:0,padding:0,overflow:"hidden",clip:"rect(0 0 0 0)",clipPath:"inset(100%)",whiteSpace:"nowrap"},role:"status","aria-live":ariaLiveType,"aria-atomic":!0},announcement)}function useAnnouncement(){let[announcement,setAnnouncement]=(0,react.useState)("");return{announce:(0,react.useCallback)(value=>{null!=value&&setAnnouncement(value)},[]),announcement}}let screenReaderInstructions={draggable:`
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `},defaultAnnouncements={onDragStart:id=>`Picked up draggable item ${id}.`,onDragOver:(id,overId)=>overId?`Draggable item ${id} was moved over droppable area ${overId}.`:`Draggable item ${id} is no longer over a droppable area.`,onDragEnd:(id,overId)=>overId?`Draggable item ${id} was dropped over droppable area ${overId}`:`Draggable item ${id} was dropped.`,onDragCancel:id=>`Dragging was cancelled. Draggable item ${id} was dropped.`};function noop(..._args){}!function(Action){Action.DragStart="dragStart",Action.DragMove="dragMove",Action.DragEnd="dragEnd",Action.DragCancel="dragCancel",Action.DragOver="dragOver",Action.RegisterDroppable="registerDroppable",Action.SetDroppableDisabled="setDroppableDisabled",Action.UnregisterDroppable="unregisterDroppable"}(Action||(Action={}));class DroppableContainersMap extends Map{get(id){var _super$get;return null!=id&&null!=(_super$get=super.get(id))?_super$get:void 0}toArray(){return Array.from(this.values())}getEnabled(){return this.toArray().filter(({disabled})=>!disabled)}getNodeFor(id){var _this$get$node$curren,_this$get;return null!=(_this$get$node$curren=null==(_this$get=this.get(id))?void 0:_this$get.node.current)?_this$get$node$curren:void 0}}let Context=/*#__PURE__*/(0,react.createContext)({activatorEvent:null,active:null,activeNode:null,activeNodeRect:null,activeNodeClientRect:null,activators:[],ariaDescribedById:{draggable:""},containerNodeRect:null,dispatch:noop,draggableNodes:{},droppableRects:/*#__PURE__*/new Map,droppableContainers:/*#__PURE__*/new DroppableContainersMap,over:null,dragOverlay:{nodeRef:{current:null},rect:null,setRef:noop},scrollableAncestors:[],scrollableAncestorRects:[],recomputeLayouts:noop,windowRect:null,willRecomputeLayouts:!1});function getInitialState(){return{draggable:{active:null,initialCoordinates:{x:0,y:0},nodes:{},translate:{x:0,y:0}},droppable:{containers:new DroppableContainersMap}}}function reducer(state,action){switch(action.type){case Action.DragStart:return{...state,draggable:{...state.draggable,initialCoordinates:action.initialCoordinates,active:action.active}};case Action.DragMove:if(!state.draggable.active)return state;return{...state,draggable:{...state.draggable,translate:{x:action.coordinates.x-state.draggable.initialCoordinates.x,y:action.coordinates.y-state.draggable.initialCoordinates.y}}};case Action.DragEnd:case Action.DragCancel:return{...state,draggable:{...state.draggable,active:null,initialCoordinates:{x:0,y:0},translate:{x:0,y:0}}};case Action.RegisterDroppable:{let{element}=action,{id}=element,containers=new DroppableContainersMap(state.droppable.containers);return containers.set(id,element),{...state,droppable:{...state.droppable,containers}}}case Action.SetDroppableDisabled:{let{id,key,disabled}=action,element=state.droppable.containers.get(id);if(!element||key!==element.key)return state;let containers=new DroppableContainersMap(state.droppable.containers);return containers.set(id,{...element,disabled}),{...state,droppable:{...state.droppable,containers}}}case Action.UnregisterDroppable:{let{id,key}=action,element=state.droppable.containers.get(id);if(!element||key!==element.key)return state;let containers=new DroppableContainersMap(state.droppable.containers);return containers.delete(id),{...state,droppable:{...state.droppable,containers}}}default:return state}}let DndMonitorContext=/*#__PURE__*/(0,react.createContext)({type:null,event:null});function useDndMonitor({onDragStart,onDragMove,onDragOver,onDragEnd,onDragCancel}){let monitorState=(0,react.useContext)(DndMonitorContext),previousMonitorState=(0,react.useRef)(monitorState);(0,react.useEffect)(()=>{if(monitorState!==previousMonitorState.current){let{type,event}=monitorState;switch(type){case Action.DragStart:null==onDragStart||onDragStart(event);break;case Action.DragMove:null==onDragMove||onDragMove(event);break;case Action.DragOver:null==onDragOver||onDragOver(event);break;case Action.DragCancel:null==onDragCancel||onDragCancel(event);break;case Action.DragEnd:null==onDragEnd||onDragEnd(event)}previousMonitorState.current=monitorState}},[monitorState,onDragStart,onDragMove,onDragOver,onDragEnd,onDragCancel])}function Accessibility({announcements=defaultAnnouncements,hiddenTextDescribedById,screenReaderInstructions}){let{announce,announcement}=useAnnouncement(),liveRegionId=(0,utilities_esm.useUniqueId)("DndLiveRegion"),[mounted,setMounted]=(0,react.useState)(!1);return(0,react.useEffect)(()=>{setMounted(!0)},[]),useDndMonitor((0,react.useMemo)(()=>({onDragStart({active}){announce(announcements.onDragStart(active.id))},onDragMove({active,over}){announcements.onDragMove&&announce(announcements.onDragMove(active.id,null==over?void 0:over.id))},onDragOver({active,over}){announce(announcements.onDragOver(active.id,null==over?void 0:over.id))},onDragEnd({active,over}){announce(announcements.onDragEnd(active.id,null==over?void 0:over.id))},onDragCancel({active}){announce(announcements.onDragCancel(active.id))}}),[announce,announcements])),mounted?(0,react_dom.createPortal)(react.createElement(react.Fragment,null,react.createElement(HiddenText,{id:hiddenTextDescribedById,value:screenReaderInstructions.draggable}),react.createElement(LiveRegion,{id:liveRegionId,announcement:announcement})),document.body):null}let defaultCoordinates=/*#__PURE__*/Object.freeze({x:0,y:0});function distanceBetween(p1,p2){return Math.sqrt(Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2))}function getRelativeTransformOrigin(event,rect){if((0,utilities_esm.isKeyboardEvent)(event))return"0 0";let eventCoordinates=(0,utilities_esm.getEventCoordinates)(event),transformOrigin={x:(eventCoordinates.x-rect.left)/rect.width*100,y:(eventCoordinates.y-rect.top)/rect.height*100};return`${transformOrigin.x}% ${transformOrigin.y}%`}function centerOfRectangle(rect,left=rect.offsetLeft,top=rect.offsetTop){return{x:left+.5*rect.width,y:top+.5*rect.height}}let closestCenter=({collisionRect,droppableContainers})=>{let centerRect=centerOfRectangle(collisionRect,collisionRect.left,collisionRect.top),minDistanceToCenter=1/0,minDroppableContainer=null;for(let droppableContainer of droppableContainers){let{rect:{current:rect}}=droppableContainer;if(rect){let distBetween=distanceBetween(centerOfRectangle(rect),centerRect);distBetween<minDistanceToCenter&&(minDistanceToCenter=distBetween,minDroppableContainer=droppableContainer.id)}}return minDroppableContainer};function adjustScale(transform,rect1,rect2){return{...transform,scaleX:rect1&&rect2?rect1.width/rect2.width:1,scaleY:rect1&&rect2?rect1.height/rect2.height:1}}function getRectDelta(rect1,rect2){return rect1&&rect2?{x:rect1.left-rect2.left,y:rect1.top-rect2.top}:defaultCoordinates}let getAdjustedRect=/*#__PURE__*/function createRectAdjustmentFn(modifier){return function adjustViewRect(viewRect,...adjustments){return adjustments.reduce((acc,adjustment)=>({...acc,top:acc.top+1*adjustment.y,bottom:acc.bottom+1*adjustment.y,left:acc.left+modifier*adjustment.x,right:acc.right+modifier*adjustment.x,offsetLeft:acc.offsetLeft+modifier*adjustment.x,offsetTop:acc.offsetTop+modifier*adjustment.y}),{...viewRect})}}(1);function isFixed(node,computedStyle=window.getComputedStyle(node)){return"fixed"===computedStyle.position}function isScrollable(node,computedStyle=window.getComputedStyle(node)){let overflowRegex=/(auto|scroll|overlay)/;return null!=["overflow","overflowX","overflowY"].find(property=>{let value=computedStyle[property];return"string"==typeof value&&overflowRegex.test(value)})}function getScrollableAncestors(element){let scrollParents=[];function findScrollableAncestors(node){if(!node)return scrollParents;if((0,utilities_esm.isDocument)(node)&&null!=node.scrollingElement&&!scrollParents.includes(node.scrollingElement))return scrollParents.push(node.scrollingElement),scrollParents;if(!(0,utilities_esm.isHTMLElement)(node)||(0,utilities_esm.isSVGElement)(node)||scrollParents.includes(node))return scrollParents;let computedStyle=window.getComputedStyle(node);return(isScrollable(node,computedStyle)&&scrollParents.push(node),isFixed(node,computedStyle))?scrollParents:findScrollableAncestors(node.parentNode)}return element?findScrollableAncestors(element.parentNode):scrollParents}function getScrollableElement(element){return utilities_esm.canUseDOM&&element?(0,utilities_esm.isWindow)(element)?element:(0,utilities_esm.isNode)(element)?(0,utilities_esm.isDocument)(element)||element===(0,utilities_esm.getOwnerDocument)(element).scrollingElement?window:(0,utilities_esm.isHTMLElement)(element)?element:null:null:null}function getScrollCoordinates(element){return(0,utilities_esm.isWindow)(element)?{x:element.scrollX,y:element.scrollY}:{x:element.scrollLeft,y:element.scrollTop}}function getScrollPosition(scrollingContainer){let minScroll={x:0,y:0},maxScroll={x:scrollingContainer.scrollWidth-scrollingContainer.clientWidth,y:scrollingContainer.scrollHeight-scrollingContainer.clientHeight},isTop=scrollingContainer.scrollTop<=minScroll.y;return{isTop,isLeft:scrollingContainer.scrollLeft<=minScroll.x,isBottom:scrollingContainer.scrollTop>=maxScroll.y,isRight:scrollingContainer.scrollLeft>=maxScroll.x,maxScroll,minScroll}}function isDocumentScrollingElement(element){return!!utilities_esm.canUseDOM&&!!element&&element===document.scrollingElement}!function(Direction){Direction[Direction.Forward=1]="Forward",Direction[Direction.Backward=-1]="Backward"}(Direction||(Direction={}));let defaultThreshold={x:.2,y:.2};function getScrollDirectionAndSpeed(scrollContainer,scrollContainerRect,{top,left,right,bottom},acceleration=10,thresholdPercentage=defaultThreshold){let{clientHeight,clientWidth}=scrollContainer,finalScrollContainerRect=isDocumentScrollingElement(scrollContainer)?{top:0,left:0,right:clientWidth,bottom:clientHeight,width:clientWidth,height:clientHeight}:scrollContainerRect,{isTop,isBottom,isLeft,isRight}=getScrollPosition(scrollContainer),direction={x:0,y:0},speed={x:0,y:0},threshold={height:finalScrollContainerRect.height*thresholdPercentage.y,width:finalScrollContainerRect.width*thresholdPercentage.x};return!isTop&&top<=finalScrollContainerRect.top+threshold.height?(direction.y=Direction.Backward,speed.y=acceleration*Math.abs((finalScrollContainerRect.top+threshold.height-top)/threshold.height)):!isBottom&&bottom>=finalScrollContainerRect.bottom-threshold.height&&(direction.y=Direction.Forward,speed.y=acceleration*Math.abs((finalScrollContainerRect.bottom-threshold.height-bottom)/threshold.height)),!isRight&&right>=finalScrollContainerRect.right-threshold.width?(direction.x=Direction.Forward,speed.x=acceleration*Math.abs((finalScrollContainerRect.right-threshold.width-right)/threshold.width)):!isLeft&&left<=finalScrollContainerRect.left+threshold.width&&(direction.x=Direction.Backward,speed.x=acceleration*Math.abs((finalScrollContainerRect.left+threshold.width-left)/threshold.width)),{direction,speed}}function getScrollElementRect(element){if(element===document.scrollingElement){let{innerWidth,innerHeight}=window;return{top:0,left:0,right:innerWidth,bottom:innerHeight,width:innerWidth,height:innerHeight}}let{top,left,right,bottom}=element.getBoundingClientRect();return{top,left,right,bottom,width:element.clientWidth,height:element.clientHeight}}function getScrollOffsets(scrollableAncestors){return scrollableAncestors.reduce((acc,node)=>(0,utilities_esm.add)(acc,getScrollCoordinates(node)),defaultCoordinates)}function getEdgeOffset(node,parent,offset=defaultCoordinates){if(!node||!(0,utilities_esm.isHTMLElement)(node))return offset;let nodeOffset={x:offset.x+node.offsetLeft,y:offset.y+node.offsetTop};return node.offsetParent===parent?nodeOffset:getEdgeOffset(node.offsetParent,parent,nodeOffset)}function getLayoutRect(element){let{offsetWidth:width,offsetHeight:height}=element,{x:offsetLeft,y:offsetTop}=getEdgeOffset(element,null);return{width,height,offsetTop,offsetLeft}}function getViewportLayoutRect(element){let{width,height,top,left}=element.getBoundingClientRect(),scrollOffsets=getScrollOffsets(getScrollableAncestors(element));return{width,height,offsetTop:top+scrollOffsets.y,offsetLeft:left+scrollOffsets.x}}function getBoundingClientRect(element){if((0,utilities_esm.isWindow)(element)){let width=window.innerWidth,height=window.innerHeight;return{top:0,left:0,right:width,bottom:height,width,height,offsetTop:0,offsetLeft:0}}let{offsetTop,offsetLeft}=getLayoutRect(element),{width,height,top,bottom,left,right}=element.getBoundingClientRect();return{width,height,top,bottom,right,left,offsetTop,offsetLeft}}function getViewRect(element){let{width,height,offsetTop,offsetLeft}=getLayoutRect(element),scrollOffsets=getScrollOffsets(getScrollableAncestors(element)),top=offsetTop-scrollOffsets.y,left=offsetLeft-scrollOffsets.x;return{width,height,top,bottom:top+height,right:left+width,left,offsetTop,offsetLeft}}function cornersOfRectangle(rect,left=rect.offsetLeft,top=rect.offsetTop){return[{x:left,y:top},{x:left+rect.width,y:top},{x:left,y:top+rect.height},{x:left+rect.width,y:top+rect.height}]}let closestCorners=({collisionRect,droppableContainers})=>{let minDistanceToCorners=1/0,minDistanceContainer=null,corners=cornersOfRectangle(collisionRect,collisionRect.left,collisionRect.top);for(let droppableContainer of droppableContainers){let{rect:{current:rect}}=droppableContainer;if(rect){let rectCorners=cornersOfRectangle(rect,"top"in rect?rect.left:void 0,"top"in rect?rect.top:void 0),effectiveDistance=Number((corners.reduce((accumulator,corner,index)=>accumulator+distanceBetween(rectCorners[index],corner),0)/4).toFixed(4));effectiveDistance<minDistanceToCorners&&(minDistanceToCorners=effectiveDistance,minDistanceContainer=droppableContainer.id)}}return minDistanceContainer};function getIntersectionRatio(entry,target){let top=Math.max(target.top,entry.offsetTop),left=Math.max(target.left,entry.offsetLeft),right=Math.min(target.left+target.width,entry.offsetLeft+entry.width),bottom=Math.min(target.top+target.height,entry.offsetTop+entry.height);if(left<right&&top<bottom){let targetArea=target.width*target.height,entryArea=entry.width*entry.height,intersectionArea=(right-left)*(bottom-top);return Number((intersectionArea/(targetArea+entryArea-intersectionArea)).toFixed(4))}return 0}let rectIntersection=({collisionRect,droppableContainers})=>{let maxIntersectionRatio=0,maxIntersectingDroppableContainer=null;for(let droppableContainer of droppableContainers){let{rect:{current:rect}}=droppableContainer;if(rect){let intersectionRatio=getIntersectionRatio(rect,collisionRect);intersectionRatio>maxIntersectionRatio&&(maxIntersectionRatio=intersectionRatio,maxIntersectingDroppableContainer=droppableContainer.id)}}return maxIntersectingDroppableContainer};function useAutoScroller({acceleration,activator=AutoScrollActivator.Pointer,canScroll,draggingRect,enabled,interval=5,order=TraversalOrder.TreeOrder,pointerCoordinates,scrollableAncestors,scrollableAncestorRects,threshold}){let[setAutoScrollInterval,clearAutoScrollInterval]=(0,utilities_esm.useInterval)(),scrollSpeed=(0,react.useRef)({x:1,y:1}),rect=(0,react.useMemo)(()=>{switch(activator){case AutoScrollActivator.Pointer:return pointerCoordinates?{top:pointerCoordinates.y,bottom:pointerCoordinates.y,left:pointerCoordinates.x,right:pointerCoordinates.x}:null;case AutoScrollActivator.DraggableRect:return draggingRect}return null},[activator,draggingRect,pointerCoordinates]),scrollDirection=(0,react.useRef)(defaultCoordinates),scrollContainerRef=(0,react.useRef)(null),autoScroll=(0,react.useCallback)(()=>{let scrollContainer=scrollContainerRef.current;if(!scrollContainer)return;let scrollLeft=scrollSpeed.current.x*scrollDirection.current.x,scrollTop=scrollSpeed.current.y*scrollDirection.current.y;scrollContainer.scrollBy(scrollLeft,scrollTop)},[]),sortedScrollableAncestors=(0,react.useMemo)(()=>order===TraversalOrder.TreeOrder?[...scrollableAncestors].reverse():scrollableAncestors,[order,scrollableAncestors]);(0,react.useEffect)(()=>{if(!enabled||!scrollableAncestors.length||!rect){clearAutoScrollInterval();return}for(let scrollContainer of sortedScrollableAncestors){if((null==canScroll?void 0:canScroll(scrollContainer))===!1)continue;let scrolllContainerRect=scrollableAncestorRects[scrollableAncestors.indexOf(scrollContainer)];if(!scrolllContainerRect)continue;let{direction,speed}=getScrollDirectionAndSpeed(scrollContainer,scrolllContainerRect,rect,acceleration,threshold);if(speed.x>0||speed.y>0){clearAutoScrollInterval(),scrollContainerRef.current=scrollContainer,setAutoScrollInterval(autoScroll,interval),scrollSpeed.current=speed,scrollDirection.current=direction;return}}scrollSpeed.current={x:0,y:0},scrollDirection.current={x:0,y:0},clearAutoScrollInterval()},[acceleration,autoScroll,canScroll,clearAutoScrollInterval,enabled,interval,JSON.stringify(rect),setAutoScrollInterval,scrollableAncestors,sortedScrollableAncestors,scrollableAncestorRects,JSON.stringify(threshold)])}function useCachedNode(draggableNodes,id){let draggableNode=null!==id?draggableNodes[id]:void 0,node=draggableNode?draggableNode.node.current:null;return(0,utilities_esm.useLazyMemo)(cachedNode=>{var _ref;return null===id?null:null!=(_ref=null!=node?node:cachedNode)?_ref:null},[node,id])}function useCombineActivators(sensors,getSyntheticHandler){return(0,react.useMemo)(()=>sensors.reduce((accumulator,sensor)=>{let{sensor:Sensor}=sensor;return[...accumulator,...Sensor.activators.map(activator=>({eventName:activator.eventName,handler:getSyntheticHandler(activator.handler,sensor)}))]},[]),[sensors,getSyntheticHandler])}function useData(data){let dataRef=(0,react.useRef)(data);return(0,utilities_esm.useIsomorphicLayoutEffect)(()=>{dataRef.current!==data&&(dataRef.current=data)},[data]),dataRef}!function(AutoScrollActivator){AutoScrollActivator[AutoScrollActivator.Pointer=0]="Pointer",AutoScrollActivator[AutoScrollActivator.DraggableRect=1]="DraggableRect"}(AutoScrollActivator||(AutoScrollActivator={})),function(TraversalOrder){TraversalOrder[TraversalOrder.TreeOrder=0]="TreeOrder",TraversalOrder[TraversalOrder.ReversedTreeOrder=1]="ReversedTreeOrder"}(TraversalOrder||(TraversalOrder={})),function(MeasuringStrategy){MeasuringStrategy[MeasuringStrategy.Always=0]="Always",MeasuringStrategy[MeasuringStrategy.BeforeDragging=1]="BeforeDragging",MeasuringStrategy[MeasuringStrategy.WhileDragging=2]="WhileDragging"}(MeasuringStrategy||(MeasuringStrategy={})),(MeasuringFrequency||(MeasuringFrequency={})).Optimized="optimized";let defaultValue=/*#__PURE__*/new Map,defaultConfig={measure:getLayoutRect,strategy:MeasuringStrategy.WhileDragging,frequency:MeasuringFrequency.Optimized};function useDroppableMeasuring(containers,{dragging,dependencies,config}){let[willRecomputeLayouts,setWillRecomputeLayouts]=(0,react.useState)(!1),{frequency,measure,strategy}={...defaultConfig,...config},containersRef=(0,react.useRef)(containers),recomputeLayouts=(0,react.useCallback)(()=>setWillRecomputeLayouts(!0),[]),recomputeLayoutsTimeoutId=(0,react.useRef)(null),disabled=isDisabled(),layoutRectMap=(0,utilities_esm.useLazyMemo)(previousValue=>{if(disabled&&!dragging)return defaultValue;if(!previousValue||previousValue===defaultValue||containersRef.current!==containers||willRecomputeLayouts){for(let container of containers)container&&(container.rect.current=container.node.current?measure(container.node.current):null);return createLayoutRectMap(containers)}return previousValue},[containers,dragging,disabled,measure,willRecomputeLayouts]);return(0,react.useEffect)(()=>{containersRef.current=containers},[containers]),(0,react.useEffect)(()=>{willRecomputeLayouts&&setWillRecomputeLayouts(!1)},[willRecomputeLayouts]),(0,react.useEffect)(function recompute(){disabled||requestAnimationFrame(recomputeLayouts)},[dragging,disabled]),(0,react.useEffect)(function forceRecomputeLayouts(){disabled||"number"!=typeof frequency||null!==recomputeLayoutsTimeoutId.current||(recomputeLayoutsTimeoutId.current=setTimeout(()=>{recomputeLayouts(),recomputeLayoutsTimeoutId.current=null},frequency))},[frequency,disabled,recomputeLayouts,...dependencies]),{layoutRectMap,recomputeLayouts,willRecomputeLayouts};function isDisabled(){switch(strategy){case MeasuringStrategy.Always:return!1;case MeasuringStrategy.BeforeDragging:return dragging;default:return!dragging}}}function createLayoutRectMap(containers){let layoutRectMap=new Map;if(containers)for(let container of containers){if(!container)continue;let{id,rect}=container;null!=rect.current&&layoutRectMap.set(id,rect.current)}return layoutRectMap}function useScrollOffsets(elements){let[scrollCoordinates,setScrollCoordinates]=(0,react.useState)(null),prevElements=(0,react.useRef)(elements),handleScroll=(0,react.useCallback)(event=>{let scrollingElement=getScrollableElement(event.target);scrollingElement&&setScrollCoordinates(scrollCoordinates=>scrollCoordinates?(scrollCoordinates.set(scrollingElement,getScrollCoordinates(scrollingElement)),new Map(scrollCoordinates)):null)},[]);return(0,react.useEffect)(()=>{let previousElements=prevElements.current;if(elements!==previousElements){cleanup(previousElements);let entries=elements.map(element=>{let scrollableElement=getScrollableElement(element);return scrollableElement?(scrollableElement.addEventListener("scroll",handleScroll,{passive:!0}),[scrollableElement,getScrollCoordinates(scrollableElement)]):null}).filter(entry=>null!=entry);setScrollCoordinates(entries.length?new Map(entries):null),prevElements.current=elements}return()=>{cleanup(elements),cleanup(previousElements)};function cleanup(elements){elements.forEach(element=>{let scrollableElement=getScrollableElement(element);null==scrollableElement||scrollableElement.removeEventListener("scroll",handleScroll)})}},[handleScroll,elements]),(0,react.useMemo)(()=>elements.length?scrollCoordinates?Array.from(scrollCoordinates.values()).reduce((acc,coordinates)=>(0,utilities_esm.add)(acc,coordinates),defaultCoordinates):getScrollOffsets(elements):defaultCoordinates,[elements,scrollCoordinates])}let defaultValue$1=[];function useScrollableAncestors(node){let previousNode=(0,react.useRef)(node),ancestors=(0,utilities_esm.useLazyMemo)(previousValue=>node?previousValue&&node&&previousNode.current&&node.parentNode===previousNode.current.parentNode?previousValue:getScrollableAncestors(node):defaultValue$1,[node]);return(0,react.useEffect)(()=>{previousNode.current=node},[node]),ancestors}function useSensorSetup(sensors){(0,react.useEffect)(()=>{if(!utilities_esm.canUseDOM)return;let teardownFns=sensors.map(({sensor})=>null==sensor.setup?void 0:sensor.setup());return()=>{for(let teardown of teardownFns)null==teardown||teardown()}},sensors.map(({sensor})=>sensor))}function useSyntheticListeners(listeners,id){return(0,react.useMemo)(()=>listeners.reduce((acc,{eventName,handler})=>(acc[eventName]=event=>{handler(event,id)},acc),{}),[listeners,id])}let useClientRect=/*#__PURE__*/createUseRectFn(getBoundingClientRect),useClientRects=/*#__PURE__*/createUseRectsFn(getBoundingClientRect);function useRect(element,getRect,forceRecompute){let previousElement=(0,react.useRef)(element);return(0,utilities_esm.useLazyMemo)(previousValue=>element?forceRecompute||!previousValue&&element||element!==previousElement.current?(0,utilities_esm.isHTMLElement)(element)&&null==element.parentNode?null:getRect(element):null!=previousValue?previousValue:null:null,[element,forceRecompute,getRect])}function createUseRectFn(getRect){return(element,forceRecompute)=>useRect(element,getRect,forceRecompute)}function createUseRectsFn(getRect){let defaultValue=[];return function useRects(elements,forceRecompute){let previousElements=(0,react.useRef)(elements);return(0,utilities_esm.useLazyMemo)(previousValue=>elements.length?forceRecompute||!previousValue&&elements.length||elements!==previousElements.current?elements.map(element=>getRect(element)):null!=previousValue?previousValue:defaultValue:defaultValue,[elements,forceRecompute])}}function getMeasurableNode(node){if(!node)return null;if(node.children.length>1)return node;let firstChild=node.children[0];return(0,utilities_esm.isHTMLElement)(firstChild)?firstChild:node}let useDragOverlayRect=/*#__PURE__*/createUseRectFn(function getDragOverlayRect(element){let{width,height,offsetLeft,offsetTop}=getLayoutRect(element);return{top:offsetTop,bottom:offsetTop+height,left:offsetLeft,right:offsetLeft+width,width,height,offsetTop,offsetLeft}});function useDragOverlayMeasuring({disabled,forceRecompute}){let[nodeRef,setRef]=(0,utilities_esm.useNodeRef)(),rect=useDragOverlayRect(disabled?null:getMeasurableNode(nodeRef.current),forceRecompute);return(0,react.useMemo)(()=>({nodeRef,rect,setRef}),[rect,nodeRef,setRef])}function useSensor(sensor,options){return(0,react.useMemo)(()=>({sensor,options:null!=options?options:{}}),[sensor,options])}function useSensors(...sensors){return(0,react.useMemo)(()=>[...sensors].filter(sensor=>null!=sensor),[...sensors])}class Listeners{constructor(target){this.target=target,this.listeners=[],this.removeAll=()=>{this.listeners.forEach(listener=>{var _this$target;return null==(_this$target=this.target)?void 0:_this$target.removeEventListener(...listener)})}}add(eventName,handler,options){var _this$target2;null==(_this$target2=this.target)||_this$target2.addEventListener(eventName,handler,options),this.listeners.push([eventName,handler,options])}}function getEventListenerTarget(target){let{EventTarget}=(0,utilities_esm.getWindow)(target);return target instanceof EventTarget?target:(0,utilities_esm.getOwnerDocument)(target)}function hasExceededDistance(delta,measurement){let dx=Math.abs(delta.x),dy=Math.abs(delta.y);return"number"==typeof measurement?Math.sqrt(dx**2+dy**2)>measurement:"x"in measurement&&"y"in measurement?dx>measurement.x&&dy>measurement.y:"x"in measurement?dx>measurement.x:"y"in measurement&&dy>measurement.y}function preventDefault(event){event.preventDefault()}function stopPropagation(event){event.stopPropagation()}!function(EventName){EventName.Click="click",EventName.DragStart="dragstart",EventName.Keydown="keydown",EventName.ContextMenu="contextmenu",EventName.Resize="resize",EventName.SelectionChange="selectionchange",EventName.VisibilityChange="visibilitychange"}(EventName||(EventName={})),function(KeyboardCode){KeyboardCode.Space="Space",KeyboardCode.Down="ArrowDown",KeyboardCode.Right="ArrowRight",KeyboardCode.Left="ArrowLeft",KeyboardCode.Up="ArrowUp",KeyboardCode.Esc="Escape",KeyboardCode.Enter="Enter"}(KeyboardCode||(KeyboardCode={}));let defaultKeyboardCodes={start:[KeyboardCode.Space,KeyboardCode.Enter],cancel:[KeyboardCode.Esc],end:[KeyboardCode.Space,KeyboardCode.Enter]},defaultKeyboardCoordinateGetter=(event,{currentCoordinates})=>{switch(event.code){case KeyboardCode.Right:return{...currentCoordinates,x:currentCoordinates.x+25};case KeyboardCode.Left:return{...currentCoordinates,x:currentCoordinates.x-25};case KeyboardCode.Down:return{...currentCoordinates,y:currentCoordinates.y+25};case KeyboardCode.Up:return{...currentCoordinates,y:currentCoordinates.y-25}}};class KeyboardSensor{constructor(props){this.props=props,this.autoScrollEnabled=!1,this.coordinates=defaultCoordinates;let{event:{target}}=props;this.props=props,this.listeners=new Listeners((0,utilities_esm.getOwnerDocument)(target)),this.windowListeners=new Listeners((0,utilities_esm.getWindow)(target)),this.handleKeyDown=this.handleKeyDown.bind(this),this.handleCancel=this.handleCancel.bind(this),this.attach()}attach(){this.handleStart(),this.windowListeners.add(EventName.Resize,this.handleCancel),this.windowListeners.add(EventName.VisibilityChange,this.handleCancel),setTimeout(()=>this.listeners.add(EventName.Keydown,this.handleKeyDown))}handleStart(){let{activeNode,onStart}=this.props;if(!activeNode.node.current)throw Error("Active draggable node is undefined");let activeNodeRect=getBoundingClientRect(activeNode.node.current),coordinates={x:activeNodeRect.left,y:activeNodeRect.top};this.coordinates=coordinates,onStart(coordinates)}handleKeyDown(event){if((0,utilities_esm.isKeyboardEvent)(event)){let{coordinates}=this,{active,context,options}=this.props,{keyboardCodes=defaultKeyboardCodes,coordinateGetter=defaultKeyboardCoordinateGetter,scrollBehavior="smooth"}=options,{code}=event;if(keyboardCodes.end.includes(code)){this.handleEnd(event);return}if(keyboardCodes.cancel.includes(code)){this.handleCancel(event);return}let newCoordinates=coordinateGetter(event,{active,context:context.current,currentCoordinates:coordinates});if(newCoordinates){let scrollDelta={x:0,y:0},{scrollableAncestors}=context.current;for(let scrollContainer of scrollableAncestors){let direction=event.code,coordinatesDelta=(0,utilities_esm.subtract)(newCoordinates,coordinates),{isTop,isRight,isLeft,isBottom,maxScroll,minScroll}=getScrollPosition(scrollContainer),scrollElementRect=getScrollElementRect(scrollContainer),clampedCoordinates={x:Math.min(direction===KeyboardCode.Right?scrollElementRect.right-scrollElementRect.width/2:scrollElementRect.right,Math.max(direction===KeyboardCode.Right?scrollElementRect.left:scrollElementRect.left+scrollElementRect.width/2,newCoordinates.x)),y:Math.min(direction===KeyboardCode.Down?scrollElementRect.bottom-scrollElementRect.height/2:scrollElementRect.bottom,Math.max(direction===KeyboardCode.Down?scrollElementRect.top:scrollElementRect.top+scrollElementRect.height/2,newCoordinates.y))},canScrollX=direction===KeyboardCode.Right&&!isRight||direction===KeyboardCode.Left&&!isLeft,canScrollY=direction===KeyboardCode.Down&&!isBottom||direction===KeyboardCode.Up&&!isTop;if(canScrollX&&clampedCoordinates.x!==newCoordinates.x){if(direction===KeyboardCode.Right&&scrollContainer.scrollLeft+coordinatesDelta.x<=maxScroll.x||direction===KeyboardCode.Left&&scrollContainer.scrollLeft+coordinatesDelta.x>=minScroll.x){scrollContainer.scrollBy({left:coordinatesDelta.x,behavior:scrollBehavior});return}scrollDelta.x=direction===KeyboardCode.Right?scrollContainer.scrollLeft-maxScroll.x:scrollContainer.scrollLeft-minScroll.x,scrollContainer.scrollBy({left:-scrollDelta.x,behavior:scrollBehavior});break}if(canScrollY&&clampedCoordinates.y!==newCoordinates.y){if(direction===KeyboardCode.Down&&scrollContainer.scrollTop+coordinatesDelta.y<=maxScroll.y||direction===KeyboardCode.Up&&scrollContainer.scrollTop+coordinatesDelta.y>=minScroll.y){scrollContainer.scrollBy({top:coordinatesDelta.y,behavior:scrollBehavior});return}scrollDelta.y=direction===KeyboardCode.Down?scrollContainer.scrollTop-maxScroll.y:scrollContainer.scrollTop-minScroll.y,scrollContainer.scrollBy({top:-scrollDelta.y,behavior:scrollBehavior});break}}this.handleMove(event,(0,utilities_esm.add)(newCoordinates,scrollDelta))}}}handleMove(event,coordinates){let{onMove}=this.props;event.preventDefault(),onMove(coordinates),this.coordinates=coordinates}handleEnd(event){let{onEnd}=this.props;event.preventDefault(),this.detach(),onEnd()}handleCancel(event){let{onCancel}=this.props;event.preventDefault(),this.detach(),onCancel()}detach(){this.listeners.removeAll(),this.windowListeners.removeAll()}}function isDistanceConstraint(constraint){return!!(constraint&&"distance"in constraint)}function isDelayConstraint(constraint){return!!(constraint&&"delay"in constraint)}KeyboardSensor.activators=[{eventName:"onKeyDown",handler:(event,{keyboardCodes=defaultKeyboardCodes,onActivation})=>{let{code}=event.nativeEvent;return!!keyboardCodes.start.includes(code)&&(event.preventDefault(),null==onActivation||onActivation({event:event.nativeEvent}),!0)}}];class AbstractPointerSensor{constructor(props,events,listenerTarget=getEventListenerTarget(props.event.target)){this.props=props,this.events=events,this.autoScrollEnabled=!0,this.activated=!1,this.timeoutId=null;let{event}=props,{target}=event;this.props=props,this.events=events,this.document=(0,utilities_esm.getOwnerDocument)(target),this.documentListeners=new Listeners(this.document),this.listeners=new Listeners(listenerTarget),this.windowListeners=new Listeners((0,utilities_esm.getWindow)(target)),this.initialCoordinates=(0,utilities_esm.getEventCoordinates)(event),this.handleStart=this.handleStart.bind(this),this.handleMove=this.handleMove.bind(this),this.handleEnd=this.handleEnd.bind(this),this.handleCancel=this.handleCancel.bind(this),this.handleKeydown=this.handleKeydown.bind(this),this.removeTextSelection=this.removeTextSelection.bind(this),this.attach()}attach(){let{events,props:{options:{activationConstraint}}}=this;if(this.listeners.add(events.move.name,this.handleMove,{passive:!1}),this.listeners.add(events.end.name,this.handleEnd),this.windowListeners.add(EventName.Resize,this.handleCancel),this.windowListeners.add(EventName.DragStart,preventDefault),this.windowListeners.add(EventName.VisibilityChange,this.handleCancel),this.windowListeners.add(EventName.ContextMenu,preventDefault),this.documentListeners.add(EventName.Keydown,this.handleKeydown),activationConstraint){if(isDistanceConstraint(activationConstraint))return;if(isDelayConstraint(activationConstraint)){this.timeoutId=setTimeout(this.handleStart,activationConstraint.delay);return}}this.handleStart()}detach(){this.listeners.removeAll(),this.windowListeners.removeAll(),setTimeout(this.documentListeners.removeAll,50),null!==this.timeoutId&&(clearTimeout(this.timeoutId),this.timeoutId=null)}handleStart(){let{initialCoordinates}=this,{onStart}=this.props;initialCoordinates&&(this.activated=!0,this.documentListeners.add(EventName.Click,stopPropagation,{capture:!0}),this.removeTextSelection(),this.documentListeners.add(EventName.SelectionChange,this.removeTextSelection),onStart(initialCoordinates))}handleMove(event){let{activated,initialCoordinates,props}=this,{onMove,options:{activationConstraint}}=props;if(!initialCoordinates)return;let coordinates=(0,utilities_esm.getEventCoordinates)(event),delta=(0,utilities_esm.subtract)(initialCoordinates,coordinates);if(!activated&&activationConstraint){if(isDelayConstraint(activationConstraint))return hasExceededDistance(delta,activationConstraint.tolerance)?this.handleCancel():void 0;if(isDistanceConstraint(activationConstraint))return null!=activationConstraint.tolerance&&hasExceededDistance(delta,activationConstraint.tolerance)?this.handleCancel():hasExceededDistance(delta,activationConstraint.distance)?this.handleStart():void 0}event.cancelable&&event.preventDefault(),onMove(coordinates)}handleEnd(){let{onEnd}=this.props;this.detach(),onEnd()}handleCancel(){let{onCancel}=this.props;this.detach(),onCancel()}handleKeydown(event){event.code===KeyboardCode.Esc&&this.handleCancel()}removeTextSelection(){var _this$document$getSel;null==(_this$document$getSel=this.document.getSelection())||_this$document$getSel.removeAllRanges()}}let events={move:{name:"pointermove"},end:{name:"pointerup"}};class PointerSensor extends AbstractPointerSensor{constructor(props){let{event}=props;super(props,events,(0,utilities_esm.getOwnerDocument)(event.target))}}PointerSensor.activators=[{eventName:"onPointerDown",handler:({nativeEvent:event},{onActivation})=>!!event.isPrimary&&0===event.button&&(null==onActivation||onActivation({event}),!0)}];let events$1={move:{name:"mousemove"},end:{name:"mouseup"}};!function(MouseButton){MouseButton[MouseButton.RightClick=2]="RightClick"}(MouseButton||(MouseButton={}));class MouseSensor extends AbstractPointerSensor{constructor(props){super(props,events$1,(0,utilities_esm.getOwnerDocument)(props.event.target))}}MouseSensor.activators=[{eventName:"onMouseDown",handler:({nativeEvent:event},{onActivation})=>event.button!==MouseButton.RightClick&&(null==onActivation||onActivation({event}),!0)}];let events$2={move:{name:"touchmove"},end:{name:"touchend"}};class TouchSensor extends AbstractPointerSensor{constructor(props){super(props,events$2)}static setup(){return window.addEventListener(events$2.move.name,noop,{capture:!1,passive:!1}),function teardown(){window.removeEventListener(events$2.move.name,noop)};function noop(){}}}function applyModifiers(modifiers,{transform,...args}){return(null==modifiers?void 0:modifiers.length)?modifiers.reduce((accumulator,modifier)=>modifier({transform:accumulator,...args}),transform):transform}TouchSensor.activators=[{eventName:"onTouchStart",handler:({nativeEvent:event},{onActivation})=>{let{touches}=event;return!(touches.length>1)&&(null==onActivation||onActivation({event}),!0)}}];let defaultSensors=[{sensor:PointerSensor,options:{}},{sensor:KeyboardSensor,options:{}}],defaultData={current:{}},ActiveDraggableContext=/*#__PURE__*/(0,react.createContext)({...defaultCoordinates,scaleX:1,scaleY:1}),DndContext=/*#__PURE__*/(0,react.memo)(function DndContext({id,autoScroll=!0,announcements,children,sensors=defaultSensors,collisionDetection=rectIntersection,measuring,modifiers,screenReaderInstructions:screenReaderInstructions$1=screenReaderInstructions,...props}){var _measuring$draggable$,_measuring$draggable,_sensorContext$curren,_dragOverlay$rect,_over$rect;let[state,dispatch]=(0,react.useReducer)(reducer,void 0,getInitialState),[monitorState,setMonitorState]=(0,react.useState)(()=>({type:null,event:null})),[isDragging,setIsDragging]=(0,react.useState)(!1),{draggable:{active:activeId,nodes:draggableNodes,translate},droppable:{containers:droppableContainers}}=state,node=activeId?draggableNodes[activeId]:null,activeRects=(0,react.useRef)({initial:null,translated:null}),active=(0,react.useMemo)(()=>{var _node$data;return null!=activeId?{id:activeId,data:null!=(_node$data=null==node?void 0:node.data)?_node$data:defaultData,rect:activeRects}:null},[activeId,node]),activeRef=(0,react.useRef)(null),[activeSensor,setActiveSensor]=(0,react.useState)(null),[activatorEvent,setActivatorEvent]=(0,react.useState)(null),latestProps=(0,react.useRef)(props),draggableDescribedById=(0,utilities_esm.useUniqueId)("DndDescribedBy",id),enabledDroppableContainers=(0,react.useMemo)(()=>droppableContainers.getEnabled(),[droppableContainers]),{layoutRectMap:droppableRects,recomputeLayouts,willRecomputeLayouts}=useDroppableMeasuring(enabledDroppableContainers,{dragging:isDragging,dependencies:[translate.x,translate.y],config:null==measuring?void 0:measuring.droppable}),activeNode=useCachedNode(draggableNodes,activeId),activationCoordinates=activatorEvent?(0,utilities_esm.getEventCoordinates)(activatorEvent):null,activeNodeRect=useRect(activeNode,null!=(_measuring$draggable$=null==measuring?void 0:null==(_measuring$draggable=measuring.draggable)?void 0:_measuring$draggable.measure)?_measuring$draggable$:getViewRect),activeNodeClientRect=useClientRect(activeNode),initialActiveNodeRectRef=(0,react.useRef)(null),initialActiveNodeRect=initialActiveNodeRectRef.current,sensorContext=(0,react.useRef)({active:null,activeNode,collisionRect:null,droppableRects,draggableNodes,draggingNodeRect:null,droppableContainers,over:null,scrollableAncestors:[],scrollAdjustedTranslate:null,translatedRect:null}),overNode=droppableContainers.getNodeFor(null==(_sensorContext$curren=sensorContext.current.over)?void 0:_sensorContext$curren.id),windowRect=useClientRect(activeNode?activeNode.ownerDocument.defaultView:null),containerNodeRect=useClientRect(activeNode?activeNode.parentElement:null),scrollableAncestors=useScrollableAncestors(activeId?null!=overNode?overNode:activeNode:null),scrollableAncestorRects=useClientRects(scrollableAncestors),dragOverlay=useDragOverlayMeasuring({disabled:null==activeId,forceRecompute:willRecomputeLayouts}),draggingNodeRect=null!=(_dragOverlay$rect=dragOverlay.rect)?_dragOverlay$rect:activeNodeRect,nodeRectDelta=draggingNodeRect===activeNodeRect?getRectDelta(activeNodeRect,initialActiveNodeRect):defaultCoordinates,modifiedTranslate=applyModifiers(modifiers,{transform:{x:translate.x-nodeRectDelta.x,y:translate.y-nodeRectDelta.y,scaleX:1,scaleY:1},activatorEvent,active,activeNodeRect:activeNodeClientRect,containerNodeRect,draggingNodeRect,over:sensorContext.current.over,overlayNodeRect:dragOverlay.rect,scrollableAncestors,scrollableAncestorRects,windowRect}),pointerCoordinates=activationCoordinates?(0,utilities_esm.add)(activationCoordinates,translate):null,scrollAdjustment=useScrollOffsets(scrollableAncestors),scrollAdjustedTranslate=(0,utilities_esm.add)(modifiedTranslate,scrollAdjustment),translatedRect=draggingNodeRect?getAdjustedRect(draggingNodeRect,modifiedTranslate):null,collisionRect=translatedRect?getAdjustedRect(translatedRect,scrollAdjustment):null,overId=active&&collisionRect?collisionDetection({active,collisionRect,droppableContainers:enabledDroppableContainers}):null,[over,setOver]=(0,react.useState)(null),transform=adjustScale(modifiedTranslate,null!=(_over$rect=null==over?void 0:over.rect)?_over$rect:null,activeNodeRect),instantiateSensor=(0,react.useCallback)((event,{sensor:Sensor,options})=>{if(!activeRef.current)return;let activeNode=draggableNodes[activeRef.current];if(!activeNode)return;let sensorInstance=new Sensor({active:activeRef.current,activeNode,event:event.nativeEvent,options,context:sensorContext,onStart(initialCoordinates){let id=activeRef.current;if(!id)return;let node=draggableNodes[id];if(!node)return;let{onDragStart}=latestProps.current,event={active:{id,data:node.data,rect:activeRects}};(0,react_dom.unstable_batchedUpdates)(()=>{dispatch({type:Action.DragStart,initialCoordinates,active:id}),setMonitorState({type:Action.DragStart,event})}),null==onDragStart||onDragStart(event)},onMove(coordinates){dispatch({type:Action.DragMove,coordinates})},onEnd:createHandler(Action.DragEnd),onCancel:createHandler(Action.DragCancel)});function createHandler(type){return async function handler(){let{active,over,scrollAdjustedTranslate}=sensorContext.current,event=null;if(active&&scrollAdjustedTranslate){let{cancelDrop}=latestProps.current;event={active:active,delta:scrollAdjustedTranslate,over},type===Action.DragEnd&&"function"==typeof cancelDrop&&await Promise.resolve(cancelDrop(event))&&(type=Action.DragCancel)}if(activeRef.current=null,(0,react_dom.unstable_batchedUpdates)(()=>{dispatch({type}),setOver(null),setIsDragging(!1),setActiveSensor(null),setActivatorEvent(null),event&&setMonitorState({type,event})}),event){let{onDragCancel,onDragEnd}=latestProps.current,handler=type===Action.DragEnd?onDragEnd:onDragCancel;null==handler||handler(event)}}}(0,react_dom.unstable_batchedUpdates)(()=>{setActiveSensor(sensorInstance),setActivatorEvent(event.nativeEvent)})},[dispatch,draggableNodes]),activators=useCombineActivators(sensors,(0,react.useCallback)((handler,sensor)=>(event,active)=>{let nativeEvent=event.nativeEvent;null!==activeRef.current||nativeEvent.dndKit||nativeEvent.defaultPrevented||!0!==handler(event,sensor.options)||(nativeEvent.dndKit={capturedBy:sensor.sensor},activeRef.current=active,instantiateSensor(event,sensor))},[instantiateSensor]));useSensorSetup(sensors),(0,utilities_esm.useIsomorphicLayoutEffect)(()=>{latestProps.current=props},Object.values(props)),(0,react.useEffect)(()=>{null!=activeId&&setIsDragging(!0)},[activeId]),(0,react.useEffect)(()=>{active||(initialActiveNodeRectRef.current=null),active&&activeNodeRect&&!initialActiveNodeRectRef.current&&(initialActiveNodeRectRef.current=activeNodeRect)},[activeNodeRect,active]),(0,react.useEffect)(()=>{let{onDragMove}=latestProps.current,{active,over}=sensorContext.current;if(!active)return;let event={active,delta:{x:scrollAdjustedTranslate.x,y:scrollAdjustedTranslate.y},over};setMonitorState({type:Action.DragMove,event}),null==onDragMove||onDragMove(event)},[scrollAdjustedTranslate.x,scrollAdjustedTranslate.y]),(0,react.useEffect)(()=>{let{active,droppableContainers,scrollAdjustedTranslate}=sensorContext.current;if(!active||!activeRef.current||!scrollAdjustedTranslate)return;let{onDragOver}=latestProps.current,overContainer=droppableContainers.get(overId),over=overContainer&&overContainer.rect.current?{id:overContainer.id,rect:overContainer.rect.current,data:overContainer.data,disabled:overContainer.disabled}:null,event={active,delta:{x:scrollAdjustedTranslate.x,y:scrollAdjustedTranslate.y},over};(0,react_dom.unstable_batchedUpdates)(()=>{setOver(over),setMonitorState({type:Action.DragOver,event}),null==onDragOver||onDragOver(event)})},[overId]),(0,utilities_esm.useIsomorphicLayoutEffect)(()=>{sensorContext.current={active,activeNode,collisionRect,droppableRects,draggableNodes,draggingNodeRect,droppableContainers,over,scrollableAncestors,scrollAdjustedTranslate:scrollAdjustedTranslate,translatedRect},activeRects.current={initial:draggingNodeRect,translated:translatedRect}},[active,activeNode,collisionRect,draggableNodes,draggingNodeRect,droppableRects,droppableContainers,over,scrollableAncestors,scrollAdjustedTranslate,translatedRect]),useAutoScroller({...getAutoScrollerOptions(),draggingRect:translatedRect,pointerCoordinates,scrollableAncestors,scrollableAncestorRects});let contextValue=(0,react.useMemo)(()=>({active,activeNode,activeNodeRect,activeNodeClientRect,activatorEvent,activators,ariaDescribedById:{draggable:draggableDescribedById},containerNodeRect,dispatch,dragOverlay,draggableNodes,droppableContainers,droppableRects,over,recomputeLayouts,scrollableAncestors,scrollableAncestorRects,willRecomputeLayouts,windowRect}),[active,activeNode,activeNodeClientRect,activeNodeRect,activatorEvent,activators,containerNodeRect,dragOverlay,dispatch,draggableNodes,draggableDescribedById,droppableContainers,droppableRects,over,recomputeLayouts,scrollableAncestors,scrollableAncestorRects,willRecomputeLayouts,windowRect]);return react.createElement(DndMonitorContext.Provider,{value:monitorState},react.createElement(Context.Provider,{value:contextValue},react.createElement(ActiveDraggableContext.Provider,{value:transform},children)),react.createElement(Accessibility,{announcements:announcements,hiddenTextDescribedById:draggableDescribedById,screenReaderInstructions:screenReaderInstructions$1}));function getAutoScrollerOptions(){let activeSensorDisablesAutoscroll=(null==activeSensor?void 0:activeSensor.autoScrollEnabled)===!1,autoScrollGloballyDisabled="object"==typeof autoScroll?!1===autoScroll.enabled:!1===autoScroll,enabled=!activeSensorDisablesAutoscroll&&!autoScrollGloballyDisabled;return"object"==typeof autoScroll?{...autoScroll,enabled}:{enabled}}}),NullContext=/*#__PURE__*/(0,react.createContext)(null),defaultRole="button";function useDraggable({id,data,disabled=!1,attributes}){let key=(0,utilities_esm.useUniqueId)("Droppable"),{active,activeNodeRect,activatorEvent,ariaDescribedById,draggableNodes,droppableRects,activators,over}=(0,react.useContext)(Context),{role=defaultRole,roleDescription="draggable",tabIndex=0}=null!=attributes?attributes:{},isDragging=(null==active?void 0:active.id)===id,transform=(0,react.useContext)(isDragging?ActiveDraggableContext:NullContext),[node,setNodeRef]=(0,utilities_esm.useNodeRef)(),listeners=useSyntheticListeners(activators,id),dataRef=useData(data);return(0,react.useEffect)(()=>(draggableNodes[id]={id,key,node,data:dataRef},()=>{let node=draggableNodes[id];node&&node.key===key&&delete draggableNodes[id]}),[draggableNodes,id]),{active,activeNodeRect,activatorEvent,attributes:(0,react.useMemo)(()=>({role,tabIndex,"aria-pressed":!!isDragging&&role===defaultRole||void 0,"aria-roledescription":roleDescription,"aria-describedby":ariaDescribedById.draggable}),[role,tabIndex,isDragging,roleDescription,ariaDescribedById.draggable]),droppableRects,isDragging,listeners:disabled?void 0:listeners,node,over,setNodeRef,transform}}function useDndContext(){return(0,react.useContext)(Context)}function useDroppable({data,disabled=!1,id}){let key=(0,utilities_esm.useUniqueId)("Droppable"),{active,dispatch,over}=(0,react.useContext)(Context),rect=(0,react.useRef)(null),[nodeRef,setNodeRef]=(0,utilities_esm.useNodeRef)(),dataRef=useData(data);return(0,utilities_esm.useIsomorphicLayoutEffect)(()=>(dispatch({type:Action.RegisterDroppable,element:{id,key,disabled,node:nodeRef,rect,data:dataRef}}),()=>dispatch({type:Action.UnregisterDroppable,key,id})),[id]),(0,react.useEffect)(()=>{dispatch({type:Action.SetDroppableDisabled,id,key,disabled})},[disabled]),{active,rect,isOver:(null==over?void 0:over.id)===id,node:nodeRef,over,setNodeRef}}function useDropAnimation({animate,adjustScale,activeId,draggableNodes,duration,easing,dragSourceOpacity,node,transform}){let[dropAnimationComplete,setDropAnimationComplete]=(0,react.useState)(!1);return(0,react.useEffect)(()=>{if(!animate||!activeId||!easing||!duration){animate&&setDropAnimationComplete(!0);return}requestAnimationFrame(()=>{var _draggableNodes$activ;let finalNode=null==(_draggableNodes$activ=draggableNodes[activeId])?void 0:_draggableNodes$activ.node.current;if(transform&&node&&finalNode&&null!==finalNode.parentNode){let fromNode=getMeasurableNode(node);if(fromNode){let from=fromNode.getBoundingClientRect(),to=getViewRect(finalNode),delta={x:from.left-to.left,y:from.top-to.top};if(Math.abs(delta.x)||Math.abs(delta.y)){let scaleDelta={scaleX:adjustScale?to.width*transform.scaleX/from.width:1,scaleY:adjustScale?to.height*transform.scaleY/from.height:1},finalTransform=utilities_esm.CSS.Transform.toString({x:transform.x-delta.x,y:transform.y-delta.y,...scaleDelta}),originalOpacity=finalNode.style.opacity;null!=dragSourceOpacity&&(finalNode.style.opacity=`${dragSourceOpacity}`),node.animate([{transform:utilities_esm.CSS.Transform.toString(transform)},{transform:finalTransform}],{easing,duration}).onfinish=()=>{node.style.display="none",setDropAnimationComplete(!0),finalNode&&null!=dragSourceOpacity&&(finalNode.style.opacity=originalOpacity)};return}}}setDropAnimationComplete(!0)})},[animate,activeId,adjustScale,draggableNodes,duration,easing,dragSourceOpacity,node,transform]),(0,utilities_esm.useIsomorphicLayoutEffect)(()=>{dropAnimationComplete&&setDropAnimationComplete(!1)},[dropAnimationComplete]),dropAnimationComplete}let defaultTransition=activatorEvent=>(0,utilities_esm.isKeyboardEvent)(activatorEvent)?"transform 250ms ease":void 0,defaultDropAnimation={duration:250,easing:"ease",dragSourceOpacity:0},DragOverlay=/*#__PURE__*/react.memo(({adjustScale=!1,children,dropAnimation=defaultDropAnimation,style:styleProp,transition=defaultTransition,modifiers,wrapperElement="div",className,zIndex=999})=>{var _active$id,_attributesSnapshot$c;let{active,activeNodeRect,activeNodeClientRect,containerNodeRect,draggableNodes,activatorEvent,over,dragOverlay,scrollableAncestors,scrollableAncestorRects,windowRect}=useDndContext(),transform=(0,react.useContext)(ActiveDraggableContext),modifiedTransform=applyModifiers(modifiers,{activatorEvent,active,activeNodeRect:activeNodeClientRect,containerNodeRect,draggingNodeRect:dragOverlay.rect,over,overlayNodeRect:dragOverlay.rect,scrollableAncestors,scrollableAncestorRects,transform,windowRect}),isDragging=null!==active,finalTransform=adjustScale?modifiedTransform:{...modifiedTransform,scaleX:1,scaleY:1},initialNodeRect=(0,utilities_esm.useLazyMemo)(previousValue=>isDragging?null!=previousValue?previousValue:activeNodeRect:null,[isDragging,activeNodeRect]),style=initialNodeRect?{position:"fixed",width:initialNodeRect.width,height:initialNodeRect.height,top:initialNodeRect.top,left:initialNodeRect.left,zIndex,transform:utilities_esm.CSS.Transform.toString(finalTransform),touchAction:"none",transformOrigin:adjustScale&&activatorEvent?getRelativeTransformOrigin(activatorEvent,initialNodeRect):void 0,transition:"function"==typeof transition?transition(activatorEvent):transition,...styleProp}:void 0,attributes=isDragging?{style,children,className,transform:finalTransform}:void 0,attributesSnapshot=(0,react.useRef)(attributes),derivedAttributes=null!=attributes?attributes:attributesSnapshot.current,{children:finalChildren,transform:_,...otherAttributes}=null!=derivedAttributes?derivedAttributes:{},prevActiveId=(0,react.useRef)(null!=(_active$id=null==active?void 0:active.id)?_active$id:null),dropAnimationComplete=useDropAnimation({animate:!!(dropAnimation&&prevActiveId.current&&!active),adjustScale,activeId:prevActiveId.current,draggableNodes,duration:null==dropAnimation?void 0:dropAnimation.duration,easing:null==dropAnimation?void 0:dropAnimation.easing,dragSourceOpacity:null==dropAnimation?void 0:dropAnimation.dragSourceOpacity,node:dragOverlay.nodeRef.current,transform:null==(_attributesSnapshot$c=attributesSnapshot.current)?void 0:_attributesSnapshot$c.transform}),shouldRender=!!(finalChildren&&(children||dropAnimation&&!dropAnimationComplete));return((0,react.useEffect)(()=>{if((null==active?void 0:active.id)!==prevActiveId.current){var _active$id2;prevActiveId.current=null!=(_active$id2=null==active?void 0:active.id)?_active$id2:null}active&&attributesSnapshot.current!==attributes&&(attributesSnapshot.current=attributes)},[active,attributes]),(0,react.useEffect)(()=>{dropAnimationComplete&&(attributesSnapshot.current=void 0)},[dropAnimationComplete]),shouldRender)?react.createElement(wrapperElement,{...otherAttributes,ref:dragOverlay.setRef},finalChildren):null})},"../packages/ui/node_modules/@dnd-kit/sortable/dist/sortable.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{SortableContext:()=>SortableContext,arrayMove:()=>arrayMove,arraySwap:()=>arraySwap,defaultAnimateLayoutChanges:()=>defaultAnimateLayoutChanges,defaultNewIndexGetter:()=>defaultNewIndexGetter,horizontalListSortingStrategy:()=>horizontalListSortingStrategy,rectSortingStrategy:()=>rectSortingStrategy,rectSwappingStrategy:()=>rectSwappingStrategy,sortableKeyboardCoordinates:()=>sortableKeyboardCoordinates,useSortable:()=>useSortable,verticalListSortingStrategy:()=>verticalListSortingStrategy});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("../packages/ui/node_modules/@dnd-kit/core/dist/core.esm.js"),_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("../packages/ui/node_modules/@dnd-kit/utilities/dist/utilities.esm.js");function arrayMove(array,from,to){let newArray=array.slice();return newArray.splice(to<0?newArray.length+to:to,0,newArray.splice(from,1)[0]),newArray}function arraySwap(array,from,to){let newArray=array.slice();return newArray[from]=array[to],newArray[to]=array[from],newArray}function getSortedRects(items,layoutRects){return items.reduce((accumulator,id,index)=>{let layoutRect=layoutRects.get(id);return layoutRect&&(accumulator[index]=layoutRect),accumulator},Array(items.length))}function isValidIndex(index){return null!==index&&index>=0}let defaultScale={scaleX:1,scaleY:1},horizontalListSortingStrategy=({layoutRects,activeNodeRect:fallbackActiveRect,activeIndex,overIndex,index})=>{var _layoutRects$activeIn;let activeNodeRect=null!=(_layoutRects$activeIn=layoutRects[activeIndex])?_layoutRects$activeIn:fallbackActiveRect;if(!activeNodeRect)return null;let itemGap=getItemGap(layoutRects,index,activeIndex);if(index===activeIndex){let newIndexRect=layoutRects[overIndex];return newIndexRect?{x:activeIndex<overIndex?newIndexRect.offsetLeft+newIndexRect.width-(activeNodeRect.offsetLeft+activeNodeRect.width):newIndexRect.offsetLeft-activeNodeRect.offsetLeft,y:0,...defaultScale}:null}return index>activeIndex&&index<=overIndex?{x:-activeNodeRect.width-itemGap,y:0,...defaultScale}:index<activeIndex&&index>=overIndex?{x:activeNodeRect.width+itemGap,y:0,...defaultScale}:{x:0,y:0,...defaultScale}};function getItemGap(layoutRects,index,activeIndex){let currentRect=layoutRects[index],previousRect=layoutRects[index-1],nextRect=layoutRects[index+1];return currentRect&&(previousRect||nextRect)?activeIndex<index?previousRect?currentRect.offsetLeft-(previousRect.offsetLeft+previousRect.width):nextRect.offsetLeft-(currentRect.offsetLeft+currentRect.width):nextRect?nextRect.offsetLeft-(currentRect.offsetLeft+currentRect.width):currentRect.offsetLeft-(previousRect.offsetLeft+previousRect.width):0}let rectSortingStrategy=({layoutRects,activeIndex,overIndex,index})=>{let newRects=arrayMove(layoutRects,overIndex,activeIndex),oldRect=layoutRects[index],newRect=newRects[index];return newRect&&oldRect?{x:newRect.offsetLeft-oldRect.offsetLeft,y:newRect.offsetTop-oldRect.offsetTop,scaleX:newRect.width/oldRect.width,scaleY:newRect.height/oldRect.height}:null},rectSwappingStrategy=({activeIndex,index,layoutRects,overIndex})=>{let oldRect,newRect;return(index===activeIndex&&(oldRect=layoutRects[index],newRect=layoutRects[overIndex]),index===overIndex&&(oldRect=layoutRects[index],newRect=layoutRects[activeIndex]),newRect&&oldRect)?{x:newRect.offsetLeft-oldRect.offsetLeft,y:newRect.offsetTop-oldRect.offsetTop,scaleX:newRect.width/oldRect.width,scaleY:newRect.height/oldRect.height}:null},defaultScale$1={scaleX:1,scaleY:1},verticalListSortingStrategy=({activeIndex,activeNodeRect:fallbackActiveRect,index,layoutRects,overIndex})=>{var _layoutRects$activeIn;let activeNodeRect=null!=(_layoutRects$activeIn=layoutRects[activeIndex])?_layoutRects$activeIn:fallbackActiveRect;if(!activeNodeRect)return null;if(index===activeIndex){let overIndexRect=layoutRects[overIndex];return overIndexRect?{x:0,y:activeIndex<overIndex?overIndexRect.offsetTop+overIndexRect.height-(activeNodeRect.offsetTop+activeNodeRect.height):overIndexRect.offsetTop-activeNodeRect.offsetTop,...defaultScale$1}:null}let itemGap=getItemGap$1(layoutRects,index,activeIndex);return index>activeIndex&&index<=overIndex?{x:0,y:-activeNodeRect.height-itemGap,...defaultScale$1}:index<activeIndex&&index>=overIndex?{x:0,y:activeNodeRect.height+itemGap,...defaultScale$1}:{x:0,y:0,...defaultScale$1}};function getItemGap$1(layoutRects,index,activeIndex){let currentRect=layoutRects[index],previousRect=layoutRects[index-1],nextRect=layoutRects[index+1];return currentRect?activeIndex<index?previousRect?currentRect.offsetTop-(previousRect.offsetTop+previousRect.height):nextRect?nextRect.offsetTop-(currentRect.offsetTop+currentRect.height):0:nextRect?nextRect.offsetTop-(currentRect.offsetTop+currentRect.height):previousRect?currentRect.offsetTop-(previousRect.offsetTop+previousRect.height):0:0}let ID_PREFIX="Sortable",Context=/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({activeIndex:-1,containerId:ID_PREFIX,disableTransforms:!1,items:[],overIndex:-1,useDragOverlay:!1,sortedRects:[],strategy:rectSortingStrategy,wasDragging:{current:!1}});function SortableContext({children,id,items:userDefinedItems,strategy=rectSortingStrategy}){let{active,dragOverlay,droppableRects,over,recomputeLayouts,willRecomputeLayouts}=(0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDndContext)(),containerId=(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX,id),useDragOverlay=null!==dragOverlay.rect,items=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>userDefinedItems.map(item=>"string"==typeof item?item:item.id),[userDefinedItems]),isDragging=null!=active,wasDragging=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1),activeIndex=active?items.indexOf(active.id):-1,isSorting=-1!==activeIndex,overIndex=over?items.indexOf(over.id):-1,previousItemsRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(items),sortedRects=getSortedRects(items,droppableRects),itemsHaveChanged=!isEqual(items,previousItemsRef.current),disableTransforms=-1!==overIndex&&-1===activeIndex||itemsHaveChanged;(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{itemsHaveChanged&&isSorting&&!willRecomputeLayouts&&recomputeLayouts()},[itemsHaveChanged,isSorting,recomputeLayouts,willRecomputeLayouts]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{previousItemsRef.current=items},[items]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{let timeoutId=setTimeout(()=>{wasDragging.current=isDragging},100);return()=>clearTimeout(timeoutId)},[isDragging]);let contextValue=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({activeIndex,containerId,disableTransforms,items,overIndex,useDragOverlay,sortedRects,strategy,wasDragging}),[activeIndex,containerId,disableTransforms,items,overIndex,sortedRects,useDragOverlay,strategy,wasDragging]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider,{value:contextValue},children)}function isEqual(arr1,arr2){return arr1.join()===arr2.join()}let defaultNewIndexGetter=({id,items,activeIndex,overIndex})=>arrayMove(items,activeIndex,overIndex).indexOf(id),defaultAnimateLayoutChanges=({containerId,isSorting,wasDragging,index,items,newIndex,previousItems,previousContainerId,transition})=>!!transition&&!!wasDragging&&(previousItems===items||index!==newIndex)&&(!!isSorting||newIndex!==index&&containerId===previousContainerId),defaultTransition={duration:200,easing:"ease"},transitionProperty="transform",disabledTransition=/*#__PURE__*/_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({property:transitionProperty,duration:0,easing:"linear"}),defaultAttributes={roleDescription:"sortable"};function useDerivedTransform({disabled,index,node,rect}){let[derivedTransform,setDerivedtransform]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),previousIndex=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(index);return(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{if(!disabled&&index!==previousIndex.current&&node.current){let initial=rect.current;if(initial){let current=(0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getBoundingClientRect)(node.current),delta={x:initial.offsetLeft-current.offsetLeft,y:initial.offsetTop-current.offsetTop,scaleX:initial.width/current.width,scaleY:initial.height/current.height};(delta.x||delta.y)&&setDerivedtransform(delta)}}index!==previousIndex.current&&(previousIndex.current=index)},[disabled,index,node,rect]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{derivedTransform&&requestAnimationFrame(()=>{setDerivedtransform(null)})},[derivedTransform]),derivedTransform}function useSortable({animateLayoutChanges=defaultAnimateLayoutChanges,attributes:userDefinedAttributes,disabled,data:customData,getNewIndex=defaultNewIndexGetter,id,strategy:localStrategy,transition=defaultTransition}){let{items,containerId,activeIndex,disableTransforms,sortedRects,overIndex,useDragOverlay,strategy:globalStrategy,wasDragging}=(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context),index=items.indexOf(id),data=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({sortable:{containerId,index,items},...customData}),[containerId,customData,index,items]),{rect,node,setNodeRef:setDroppableNodeRef}=(0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDroppable)({id,data}),{active,activeNodeRect,activatorEvent,attributes,setNodeRef:setDraggableNodeRef,listeners,isDragging,over,transform}=(0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDraggable)({id,data,attributes:{...defaultAttributes,...userDefinedAttributes},disabled}),setNodeRef=(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useCombinedRefs)(setDroppableNodeRef,setDraggableNodeRef),isSorting=!!active,displaceItem=isSorting&&wasDragging.current&&!disableTransforms&&isValidIndex(activeIndex)&&isValidIndex(overIndex),shouldDisplaceDragSource=!useDragOverlay&&isDragging,dragSourceDisplacement=shouldDisplaceDragSource&&displaceItem?transform:null,finalTransform=displaceItem?null!=dragSourceDisplacement?dragSourceDisplacement:(null!=localStrategy?localStrategy:globalStrategy)({layoutRects:sortedRects,activeNodeRect,activeIndex,overIndex,index}):null,newIndex=isValidIndex(activeIndex)&&isValidIndex(overIndex)?getNewIndex({id,items,activeIndex,overIndex}):index,prevItems=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(items),itemsHaveChanged=items!==prevItems.current,prevNewIndex=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(newIndex),previousContainerId=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(containerId),shouldAnimateLayoutChanges=animateLayoutChanges({active,containerId,isDragging,isSorting,id,index,items,newIndex:prevNewIndex.current,previousItems:prevItems.current,previousContainerId:previousContainerId.current,transition,wasDragging:wasDragging.current}),derivedTransform=useDerivedTransform({disabled:!shouldAnimateLayoutChanges,index,node,rect});return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{isSorting&&prevNewIndex.current!==newIndex&&(prevNewIndex.current=newIndex),containerId!==previousContainerId.current&&(previousContainerId.current=containerId),items!==prevItems.current&&(prevItems.current=items)},[isSorting,newIndex,containerId,items]),{active,attributes,activatorEvent,rect,index,isSorting,isDragging,listeners,node,overIndex,over,setNodeRef,setDroppableNodeRef,setDraggableNodeRef,transform:null!=derivedTransform?derivedTransform:finalTransform,transition:getTransition()};function getTransition(){return derivedTransform||itemsHaveChanged&&prevNewIndex.current===index?disabledTransition:shouldDisplaceDragSource||!transition?void 0:isSorting||shouldAnimateLayoutChanges?_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({...transition,property:transitionProperty}):void 0}}let directions=[_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left],sortableKeyboardCoordinates=(event,{context:{active,droppableContainers,translatedRect,scrollableAncestors}})=>{if(directions.includes(event.code)){if(event.preventDefault(),!active||!translatedRect)return;let filteredContainers=[];droppableContainers.getEnabled().forEach(entry=>{if(!entry||(null==entry?void 0:entry.disabled))return;let node=null==entry?void 0:entry.node.current;if(!node)return;let rect=(0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getViewRect)(node),container={...entry,rect:{current:rect}};switch(event.code){case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down:translatedRect.top+translatedRect.height<=rect.top&&filteredContainers.push(container);break;case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up:translatedRect.top>=rect.top+rect.height&&filteredContainers.push(container);break;case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left:translatedRect.left>=rect.left+rect.width&&filteredContainers.push(container);break;case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right:translatedRect.left+translatedRect.width<=rect.left&&filteredContainers.push(container)}});let closestId=(0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.closestCorners)({active,collisionRect:translatedRect,droppableContainers:filteredContainers});if(closestId){var _droppableContainers$;let newNode=null==(_droppableContainers$=droppableContainers.get(closestId))?void 0:_droppableContainers$.node.current;if(newNode){let hasDifferentScrollAncestors=(0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getScrollableAncestors)(newNode).some((element,index)=>scrollableAncestors[index]!==element),newRect=(0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getViewRect)(newNode),offset=hasDifferentScrollAncestors?{x:0,y:0}:{x:translatedRect.width-newRect.width,y:translatedRect.height-newRect.height};return{x:newRect.left-offset.x,y:newRect.top-offset.y}}}}}},"../packages/ui/node_modules/@dnd-kit/utilities/dist/utilities.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{CSS:()=>CSS,add:()=>add,canUseDOM:()=>canUseDOM,findFirstFocusableNode:()=>findFirstFocusableNode,getEventCoordinates:()=>getEventCoordinates,getOwnerDocument:()=>getOwnerDocument,getWindow:()=>getWindow,hasViewportRelativeCoordinates:()=>hasViewportRelativeCoordinates,isDocument:()=>isDocument,isHTMLElement:()=>isHTMLElement,isKeyboardEvent:()=>isKeyboardEvent,isNode:()=>isNode,isSVGElement:()=>isSVGElement,isTouchEvent:()=>isTouchEvent,isWindow:()=>isWindow,subtract:()=>subtract,useCombinedRefs:()=>useCombinedRefs,useEvent:()=>useEvent,useInterval:()=>useInterval,useIsomorphicLayoutEffect:()=>useIsomorphicLayoutEffect,useLatestValue:()=>useLatestValue,useLazyMemo:()=>useLazyMemo,useNodeRef:()=>useNodeRef,usePrevious:()=>usePrevious,useUniqueId:()=>useUniqueId});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");function useCombinedRefs(){for(var _len=arguments.length,refs=Array(_len),_key=0;_key<_len;_key++)refs[_key]=arguments[_key];return(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>node=>{refs.forEach(ref=>ref(node))},refs)}let canUseDOM="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement;function isWindow(element){let elementString=Object.prototype.toString.call(element);return"[object Window]"===elementString||"[object global]"===elementString}function isNode(node){return"nodeType"in node}function getWindow(target){var _target$ownerDocument,_target$ownerDocument2;return target?isWindow(target)?target:isNode(target)&&null!=(_target$ownerDocument=null==(_target$ownerDocument2=target.ownerDocument)?void 0:_target$ownerDocument2.defaultView)?_target$ownerDocument:window:window}function isDocument(node){let{Document}=getWindow(node);return node instanceof Document}function isHTMLElement(node){return!isWindow(node)&&node instanceof getWindow(node).HTMLElement}function isSVGElement(node){return node instanceof getWindow(node).SVGElement}function getOwnerDocument(target){return target?isWindow(target)?target.document:isNode(target)?isDocument(target)?target:isHTMLElement(target)||isSVGElement(target)?target.ownerDocument:document:document:document}let useIsomorphicLayoutEffect=canUseDOM?react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect:react__WEBPACK_IMPORTED_MODULE_0__.useEffect;function useEvent(handler){let handlerRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(handler);return useIsomorphicLayoutEffect(()=>{handlerRef.current=handler}),(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return null==handlerRef.current?void 0:handlerRef.current(...args)},[])}function useInterval(){let intervalRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);return[(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((listener,duration)=>{intervalRef.current=setInterval(listener,duration)},[]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{null!==intervalRef.current&&(clearInterval(intervalRef.current),intervalRef.current=null)},[])]}function useLatestValue(value,dependencies){void 0===dependencies&&(dependencies=[value]);let valueRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);return useIsomorphicLayoutEffect(()=>{valueRef.current!==value&&(valueRef.current=value)},dependencies),valueRef}function useLazyMemo(callback,dependencies){let valueRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();return(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{let newValue=callback(valueRef.current);return valueRef.current=newValue,newValue},[...dependencies])}function useNodeRef(onChange){let onChangeHandler=useEvent(onChange),node=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),setNodeRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(element=>{element!==node.current&&(null==onChangeHandler||onChangeHandler(element,node.current)),node.current=element},[]);return[node,setNodeRef]}function usePrevious(value){let ref=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{ref.current=value},[value]),ref.current}let ids={};function useUniqueId(prefix,value){return(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{if(value)return value;let id=null==ids[prefix]?0:ids[prefix]+1;return ids[prefix]=id,prefix+"-"+id},[prefix,value])}function createAdjustmentFn(modifier){return function(object){for(var _len=arguments.length,adjustments=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)adjustments[_key-1]=arguments[_key];return adjustments.reduce((accumulator,adjustment)=>{for(let[key,valueAdjustment]of Object.entries(adjustment)){let value=accumulator[key];null!=value&&(accumulator[key]=value+modifier*valueAdjustment)}return accumulator},{...object})}}let add=/*#__PURE__*/createAdjustmentFn(1),subtract=/*#__PURE__*/createAdjustmentFn(-1);function hasViewportRelativeCoordinates(event){return"clientX"in event&&"clientY"in event}function isKeyboardEvent(event){if(!event)return!1;let{KeyboardEvent}=getWindow(event.target);return KeyboardEvent&&event instanceof KeyboardEvent}function isTouchEvent(event){if(!event)return!1;let{TouchEvent}=getWindow(event.target);return TouchEvent&&event instanceof TouchEvent}function getEventCoordinates(event){if(isTouchEvent(event)){if(event.touches&&event.touches.length){let{clientX:x,clientY:y}=event.touches[0];return{x,y}}if(event.changedTouches&&event.changedTouches.length){let{clientX:x,clientY:y}=event.changedTouches[0];return{x,y}}}return hasViewportRelativeCoordinates(event)?{x:event.clientX,y:event.clientY}:null}let CSS=/*#__PURE__*/Object.freeze({Translate:{toString(transform){if(!transform)return;let{x,y}=transform;return"translate3d("+(x?Math.round(x):0)+"px, "+(y?Math.round(y):0)+"px, 0)"}},Scale:{toString(transform){if(!transform)return;let{scaleX,scaleY}=transform;return"scaleX("+scaleX+") scaleY("+scaleY+")"}},Transform:{toString(transform){if(transform)return[CSS.Translate.toString(transform),CSS.Scale.toString(transform)].join(" ")}},Transition:{toString(_ref){let{property,duration,easing}=_ref;return property+" "+duration+"ms "+easing}}}),SELECTOR="a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";function findFirstFocusableNode(element){return element.matches(SELECTOR)?element:element.querySelector(SELECTOR)}}}]);
//# sourceMappingURL=8774.d5ace3a5.iframe.bundle.js.map